"""
LangGraph State Schema for the Agentic AI Flow system.

This module defines the TypedDict state schema used by LangGraph
for managing state across the multi-agent workflow.
"""

from typing import Annotated, Sequence, TypedDict, Optional, List, Dict, Any
from langchain_core.messages import BaseMessage
from langgraph.graph.message import add_messages
from langgraph.prebuilt.chat_agent_executor import AgentState as BaseAgentState
import operator

from agents.state.models import (
    DocumentSource,
    SchemaGroup,
    ExecutionPlan,
    AgentOutput,
    ReviewDecision
)


# =============================================================================
# AGENT-SPECIFIC STATE SCHEMAS (for create_react_agent)
# =============================================================================

class PlannerAgentState(BaseAgentState):
    """
    Extended state schema for the Planner Agent.

    Extends BaseAgentState (which has 'messages' and 'remaining_steps')
    with custom fields needed by the planner tools.

    This state schema is passed to create_react_agent via state_schema parameter
    so that InjectedState can access these custom fields.

    Note: The system relies on document IDs (available_documents), not workspace_id.
    Workspaces are only used for grouping documents at the access control layer.
    """
    # Custom fields for planner
    available_documents: List[DocumentSource]
    user_query: str


class RetrievalAgentState(BaseAgentState):
    """
    Extended state schema for Retrieval Agents (SQL, Vector, Graph, Generic).

    These agents need access to the execution plan and schema groups.
    """
    execution_plan: Optional[ExecutionPlan]
    schema_groups: List[SchemaGroup]
    user_query: str


def merge_agent_outputs(
    existing: List[AgentOutput],
    new: List[AgentOutput]
) -> List[AgentOutput]:
    """
    Custom reducer for merging agent outputs.

    Updates existing outputs if task_id matches, otherwise appends.
    This allows agents to update their outputs during refinement.
    """
    if not existing:
        return new
    if not new:
        return existing

    # Create a dict for quick lookup
    existing_dict = {o.task_id: o for o in existing}

    # Update or add new outputs
    for output in new:
        existing_dict[output.task_id] = output

    return list(existing_dict.values())


class AnalyticsAgentState(TypedDict):
    """
    Main state schema for the analytics multi-agent workflow.

    This TypedDict defines all the state that flows through the
    LangGraph workflow, including inputs, intermediate results,
    and final outputs.

    Attributes:
        messages: Conversation history with automatic message accumulation
        user_query: The original user query
        workspace_id: Workspace context for document access
        chat_history: Previous conversation for context resolution

        available_documents: Documents found by document routing
        schema_groups: Grouped documents by schema compatibility

        execution_plan: Plan generated by Planner Agent

        agent_outputs: Results from retrieval agents (accumulated)

        review_iteration: Current iteration of review loop
        max_iterations: Maximum allowed review iterations
        review_decision: Latest decision from Reviewer Agent

        final_response: Final formatted response
        data_sources: Sources used in the response

        active_agent: Currently executing agent
        error: Any error that occurred
    """

    # ==========================================================================
    # INPUT STATE
    # ==========================================================================

    # Messages with automatic accumulation via add_messages reducer
    messages: Annotated[Sequence[BaseMessage], add_messages]

    # Original query and context
    user_query: str
    workspace_id: str
    chat_history: List[Dict[str, str]]

    # ==========================================================================
    # DOCUMENT CONTEXT (populated by Planner)
    # ==========================================================================

    # Documents found by document routing
    available_documents: List[DocumentSource]

    # Documents grouped by schema compatibility
    schema_groups: List[SchemaGroup]

    # ==========================================================================
    # PLANNING STATE
    # ==========================================================================

    # Execution plan from Planner Agent
    execution_plan: Optional[ExecutionPlan]

    # ==========================================================================
    # EXECUTION STATE
    # ==========================================================================

    # Agent outputs with custom reducer for merging/updating
    # Using operator.add for simple list accumulation
    # In production, consider using merge_agent_outputs for updates
    agent_outputs: Annotated[List[AgentOutput], operator.add]

    # ==========================================================================
    # REVIEW STATE
    # ==========================================================================

    # Review loop control
    review_iteration: int
    max_iterations: int

    # Latest review decision
    review_decision: Optional[ReviewDecision]

    # ==========================================================================
    # OUTPUT STATE
    # ==========================================================================

    # Final formatted response (markdown)
    final_response: Optional[str]

    # Data sources used
    data_sources: List[str]

    # Structured data for programmatic access
    structured_data: Dict[str, Any]

    # ==========================================================================
    # CONTROL STATE
    # ==========================================================================

    # Currently active agent (for tracking/debugging)
    active_agent: Optional[str]

    # Error state
    error: Optional[str]


def create_initial_state(
    user_query: str,
    workspace_id: str,
    chat_history: Optional[List[Dict[str, str]]] = None,
    max_iterations: int = 3,
    accessible_doc_ids: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    Create the initial state for the workflow.

    Args:
        user_query: The user's query
        workspace_id: Workspace ID for document access
        chat_history: Optional previous conversation history
        max_iterations: Maximum review iterations allowed
        accessible_doc_ids: List of accessible document IDs for the user

    Returns:
        Initial state dictionary
    """
    from langchain_core.messages import HumanMessage
    import logging

    logger = logging.getLogger(__name__)

    # Convert document IDs to DocumentSource objects for the workflow
    available_documents = []
    if accessible_doc_ids:
        # Try to fetch actual filenames from database
        doc_info_map = {}
        try:
            from sqlalchemy import text
            # Try multiple import paths for compatibility
            try:
                from db.database import get_db_session
            except ImportError:
                import os, sys
                backend_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
                if backend_path not in sys.path:
                    sys.path.insert(0, backend_path)
                from db.database import get_db_session

            with get_db_session() as db:
                doc_ids_str = ", ".join([f"'{doc_id}'" for doc_id in accessible_doc_ids])
                result = db.execute(text(f"""
                    SELECT id::text, original_filename
                    FROM documents
                    WHERE id::text IN ({doc_ids_str})
                """))
                for row in result.fetchall():
                    doc_info_map[row[0]] = row[1] or f"doc_{row[0][:8]}"

            logger.debug(f"[create_initial_state] Fetched filenames for {len(doc_info_map)} documents")
        except Exception as e:
            logger.warning(f"[create_initial_state] Could not fetch filenames: {e}")

        for doc_id in accessible_doc_ids:
            doc_id_str = str(doc_id)
            filename = doc_info_map.get(doc_id_str, f"doc_{doc_id_str[:8]}")
            available_documents.append(DocumentSource(
                document_id=doc_id_str,
                filename=filename,
                workspace_id=workspace_id,
                schema_type="unknown"  # Will be enriched by routing tools
            ))

    return {
        # Input
        "messages": [HumanMessage(content=user_query)],
        "user_query": user_query,
        "workspace_id": workspace_id,
        "chat_history": chat_history or [],

        # Document context - pre-populated with accessible documents
        "available_documents": available_documents,
        "schema_groups": [],

        # Planning (to be populated)
        "execution_plan": None,

        # Execution
        "agent_outputs": [],

        # Review
        "review_iteration": 0,
        "max_iterations": max_iterations,
        "review_decision": None,

        # Output
        "final_response": None,
        "data_sources": [],
        "structured_data": {},

        # Control
        "active_agent": None,
        "error": None,
    }


# =============================================================================
# SUBGRAPH STATES
# =============================================================================

class RetrievalTeamState(TypedDict):
    """
    State for the Retrieval Team subgraph.

    This is a subset of the main state focused on
    retrieval operations.
    """
    messages: Annotated[Sequence[BaseMessage], add_messages]
    execution_plan: ExecutionPlan
    schema_groups: List[SchemaGroup]
    agent_outputs: Annotated[List[AgentOutput], operator.add]
    active_agent: Optional[str]
    workspace_id: str


class ReviewerState(TypedDict):
    """
    State for the Reviewer Agent.
    """
    messages: Annotated[Sequence[BaseMessage], add_messages]
    execution_plan: ExecutionPlan
    agent_outputs: List[AgentOutput]
    review_iteration: int
    max_iterations: int
    review_decision: Optional[ReviewDecision]


class SummaryState(TypedDict):
    """
    State for the Summary Agent.
    """
    messages: Annotated[Sequence[BaseMessage], add_messages]
    user_query: str
    execution_plan: ExecutionPlan
    agent_outputs: List[AgentOutput]
    review_decision: ReviewDecision
    final_response: Optional[str]
    data_sources: List[str]
    structured_data: Dict[str, Any]
