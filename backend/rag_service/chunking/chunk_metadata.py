"""
Chunk metadata definitions for domain-aware document processing.

This module defines the metadata structures for chunks, including:
- ChunkingProfile: Pre-classification results that guide chunking strategy
- UniversalChunkMetadata: Core metadata for all chunks
- Domain-specific metadata extensions for legal, academic, medical, etc.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from enum import Enum


class ContentDensity(Enum):
    """Content density classification."""
    SPARSE = "sparse"
    NORMAL = "normal"
    DENSE = "dense"


class StructureType(Enum):
    """Document structure type classification."""
    TABULAR = "tabular"
    HIERARCHICAL = "hierarchical"
    NARRATIVE = "narrative"
    CLAUSE_BASED = "clause_based"
    FORM_BASED = "form_based"
    MIXED = "mixed"


class Complexity(Enum):
    """Document complexity classification."""
    SIMPLE = "simple"
    MODERATE = "moderate"
    COMPLEX = "complex"


@dataclass
class ChunkingProfile:
    """
    Pre-classification results that guide the chunking strategy selection.
    Generated by the DocumentClassifier before chunking begins.
    """
    # Document classification
    document_type: str
    document_domain: str
    content_density: str = "normal"
    structure_type: str = "mixed"
    complexity: str = "moderate"

    # Size-based parameters
    total_tokens: int = 0
    total_chars: int = 0
    is_small_doc: bool = False  # < 1000 tokens
    is_large_doc: bool = False  # > 10000 tokens

    # Structural markers detected
    has_tables: bool = False
    has_headers: bool = False
    has_lists: bool = False
    has_code: bool = False
    has_equations: bool = False
    has_numbered_clauses: bool = False
    has_citations: bool = False
    has_form_fields: bool = False
    has_dates: bool = False
    has_amounts: bool = False

    # Domain-specific elements
    domain_specific_elements: Dict[str, bool] = field(default_factory=dict)

    # Recommended chunking parameters
    recommended_strategy: str = "semantic_header"
    recommended_chunk_size: int = 512
    recommended_overlap_percent: int = 10
    is_atomic_unit: bool = False

    # Elements to preserve
    preserve_elements: List[str] = field(default_factory=list)
    special_handling: List[str] = field(default_factory=list)

    # Classification confidence
    confidence: float = 0.5
    reasoning: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "document_type": self.document_type,
            "document_domain": self.document_domain,
            "content_density": self.content_density,
            "structure_type": self.structure_type,
            "complexity": self.complexity,
            "total_tokens": self.total_tokens,
            "total_chars": self.total_chars,
            "is_small_doc": self.is_small_doc,
            "is_large_doc": self.is_large_doc,
            "has_tables": self.has_tables,
            "has_headers": self.has_headers,
            "has_lists": self.has_lists,
            "has_code": self.has_code,
            "has_equations": self.has_equations,
            "has_numbered_clauses": self.has_numbered_clauses,
            "has_citations": self.has_citations,
            "has_form_fields": self.has_form_fields,
            "has_dates": self.has_dates,
            "has_amounts": self.has_amounts,
            "domain_specific_elements": self.domain_specific_elements,
            "recommended_strategy": self.recommended_strategy,
            "recommended_chunk_size": self.recommended_chunk_size,
            "recommended_overlap_percent": self.recommended_overlap_percent,
            "is_atomic_unit": self.is_atomic_unit,
            "preserve_elements": self.preserve_elements,
            "special_handling": self.special_handling,
            "confidence": self.confidence,
            "reasoning": self.reasoning,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ChunkingProfile":
        """Create from dictionary."""
        return cls(**data)


@dataclass
class UniversalChunkMetadata:
    """
    Core metadata for all chunks, regardless of domain.
    This is the base metadata that every chunk will have.
    """
    # === Core Identification ===
    chunk_id: str = ""
    parent_doc_id: str = ""
    source: str = ""
    file_path: str = ""

    # === Position & Navigation ===
    chunk_index: int = 0
    total_chunks: int = 0
    page_number: Optional[int] = None
    heading_path: str = ""

    # === Document Classification ===
    document_type: str = "other"
    document_domain: str = "general"
    content_density: str = "normal"
    structure_type: str = "mixed"

    # === Chunking Strategy Applied ===
    chunking_strategy: str = "semantic_header"
    chunk_size_used: int = 512
    overlap_applied: int = 0
    is_atomic: bool = False

    # === Content Markers (Universal) ===
    contains_table: bool = False
    contains_list: bool = False
    contains_code: bool = False
    contains_image_ref: bool = False
    contains_equation: bool = False

    # === Temporal Data ===
    dates_normalized: List[str] = field(default_factory=list)
    dates_raw: List[str] = field(default_factory=list)
    primary_date: Optional[str] = None
    date_context: str = ""  # "transaction"|"publication"|"effective"|...
    date_year: Optional[int] = None
    date_month: Optional[int] = None
    date_day: Optional[int] = None

    # === Cross-References ===
    parent_chunk_id: Optional[str] = None
    child_chunk_ids: List[str] = field(default_factory=list)
    related_chunk_ids: List[str] = field(default_factory=list)
    external_references: List[str] = field(default_factory=list)

    # === Quality & Importance ===
    importance_score: float = 0.5
    content_quality: str = "medium"  # high|medium|low
    is_key_section: bool = False  # Abstract, Summary, Conclusion, etc.

    # === Original header metadata (for backward compatibility) ===
    header_1: Optional[str] = None
    header_2: Optional[str] = None
    header_3: Optional[str] = None
    header_4: Optional[str] = None
    header_5: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for storage."""
        result = {
            "chunk_id": self.chunk_id,
            "parent_doc_id": self.parent_doc_id,
            "source": self.source,
            "file_path": self.file_path,
            "chunk_index": self.chunk_index,
            "total_chunks": self.total_chunks,
            "heading_path": self.heading_path,
            "document_type": self.document_type,
            "document_domain": self.document_domain,
            "content_density": self.content_density,
            "structure_type": self.structure_type,
            "chunking_strategy": self.chunking_strategy,
            "chunk_size_used": self.chunk_size_used,
            "overlap_applied": self.overlap_applied,
            "is_atomic": self.is_atomic,
            "contains_table": self.contains_table,
            "contains_list": self.contains_list,
            "contains_code": self.contains_code,
            "contains_image_ref": self.contains_image_ref,
            "contains_equation": self.contains_equation,
            "dates_normalized": self.dates_normalized,
            "dates_raw": self.dates_raw,
            "date_context": self.date_context,
            "importance_score": self.importance_score,
            "content_quality": self.content_quality,
            "is_key_section": self.is_key_section,
        }

        # Add optional fields if present
        if self.page_number is not None:
            result["page_number"] = self.page_number
        if self.primary_date:
            result["primary_date"] = self.primary_date
        if self.date_year is not None:
            result["date_year"] = self.date_year
        if self.date_month is not None:
            result["date_month"] = self.date_month
        if self.date_day is not None:
            result["date_day"] = self.date_day
        if self.parent_chunk_id:
            result["parent_chunk_id"] = self.parent_chunk_id
        if self.child_chunk_ids:
            result["child_chunk_ids"] = self.child_chunk_ids
        if self.related_chunk_ids:
            result["related_chunk_ids"] = self.related_chunk_ids
        if self.external_references:
            result["external_references"] = self.external_references

        # Add header metadata for backward compatibility
        for i in range(1, 6):
            header_val = getattr(self, f"header_{i}", None)
            if header_val:
                result[f"Header {i}"] = header_val

        return result


@dataclass
class LegalChunkMetadata(UniversalChunkMetadata):
    """Extended metadata for legal documents."""
    clause_number: Optional[str] = None
    clause_hierarchy: List[str] = field(default_factory=list)
    clause_title: Optional[str] = None
    references_clauses: List[str] = field(default_factory=list)
    is_definition: bool = False
    party_names: List[str] = field(default_factory=list)
    effective_date: Optional[str] = None
    jurisdiction: Optional[str] = None
    is_recital: bool = False
    is_signature_block: bool = False

    def to_dict(self) -> Dict[str, Any]:
        result = super().to_dict()
        result.update({
            "clause_number": self.clause_number,
            "clause_hierarchy": self.clause_hierarchy,
            "clause_title": self.clause_title,
            "references_clauses": self.references_clauses,
            "is_definition": self.is_definition,
            "party_names": self.party_names,
            "effective_date": self.effective_date,
            "jurisdiction": self.jurisdiction,
            "is_recital": self.is_recital,
            "is_signature_block": self.is_signature_block,
        })
        return result


@dataclass
class AcademicChunkMetadata(UniversalChunkMetadata):
    """Extended metadata for academic/research documents."""
    section_type: str = ""  # abstract|intro|methods|results|discussion|conclusion
    citations_in_chunk: List[str] = field(default_factory=list)
    figures_referenced: List[str] = field(default_factory=list)
    tables_referenced: List[str] = field(default_factory=list)
    equations_present: bool = False
    is_abstract: bool = False
    is_bibliography: bool = False
    academic_keywords: List[str] = field(default_factory=list)
    doi: Optional[str] = None
    authors: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        result = super().to_dict()
        result.update({
            "section_type": self.section_type,
            "citations_in_chunk": self.citations_in_chunk,
            "figures_referenced": self.figures_referenced,
            "tables_referenced": self.tables_referenced,
            "equations_present": self.equations_present,
            "is_abstract": self.is_abstract,
            "is_bibliography": self.is_bibliography,
            "academic_keywords": self.academic_keywords,
            "doi": self.doi,
            "authors": self.authors,
        })
        return result


@dataclass
class MedicalChunkMetadata(UniversalChunkMetadata):
    """Extended metadata for medical/healthcare documents."""
    section_type: str = ""  # HPI|PMH|medications|assessment|plan|vitals
    icd_codes: List[str] = field(default_factory=list)
    cpt_codes: List[str] = field(default_factory=list)
    medications_mentioned: List[str] = field(default_factory=list)
    vitals_present: bool = False
    lab_values_present: bool = False
    is_phi_redacted: bool = False
    patient_id_masked: Optional[str] = None
    provider_name: Optional[str] = None
    facility_name: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        result = super().to_dict()
        result.update({
            "section_type": self.section_type,
            "icd_codes": self.icd_codes,
            "cpt_codes": self.cpt_codes,
            "medications_mentioned": self.medications_mentioned,
            "vitals_present": self.vitals_present,
            "lab_values_present": self.lab_values_present,
            "is_phi_redacted": self.is_phi_redacted,
            "patient_id_masked": self.patient_id_masked,
            "provider_name": self.provider_name,
            "facility_name": self.facility_name,
        })
        return result


@dataclass
class EngineeringChunkMetadata(UniversalChunkMetadata):
    """Extended metadata for engineering/technical documents."""
    requirement_ids: List[str] = field(default_factory=list)
    traces_to: List[str] = field(default_factory=list)
    verified_by: List[str] = field(default_factory=list)
    subsystem: Optional[str] = None
    version: Optional[str] = None
    diagrams_referenced: List[str] = field(default_factory=list)
    priority_level: str = ""  # shall|should|may
    tolerance_specs: List[str] = field(default_factory=list)
    interfaces_mentioned: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        result = super().to_dict()
        result.update({
            "requirement_ids": self.requirement_ids,
            "traces_to": self.traces_to,
            "verified_by": self.verified_by,
            "subsystem": self.subsystem,
            "version": self.version,
            "diagrams_referenced": self.diagrams_referenced,
            "priority_level": self.priority_level,
            "tolerance_specs": self.tolerance_specs,
            "interfaces_mentioned": self.interfaces_mentioned,
        })
        return result


@dataclass
class EducationChunkMetadata(UniversalChunkMetadata):
    """Extended metadata for educational documents."""
    chapter: Optional[str] = None
    unit: Optional[str] = None
    learning_objectives: List[str] = field(default_factory=list)
    contains_exercise: bool = False
    contains_answer: bool = False
    exercise_number: Optional[str] = None
    difficulty_level: str = ""  # beginner|intermediate|advanced
    key_terms: List[str] = field(default_factory=list)
    prerequisites: List[str] = field(default_factory=list)
    grade_level: Optional[str] = None
    is_summary: bool = False
    is_example: bool = False

    def to_dict(self) -> Dict[str, Any]:
        result = super().to_dict()
        result.update({
            "chapter": self.chapter,
            "unit": self.unit,
            "learning_objectives": self.learning_objectives,
            "contains_exercise": self.contains_exercise,
            "contains_answer": self.contains_answer,
            "exercise_number": self.exercise_number,
            "difficulty_level": self.difficulty_level,
            "key_terms": self.key_terms,
            "prerequisites": self.prerequisites,
            "grade_level": self.grade_level,
            "is_summary": self.is_summary,
            "is_example": self.is_example,
        })
        return result


@dataclass
class FinancialChunkMetadata(UniversalChunkMetadata):
    """Extended metadata for financial documents."""
    amounts_detected: List[float] = field(default_factory=list)
    currency: Optional[str] = None
    total_amount: Optional[float] = None
    subtotal_amount: Optional[float] = None
    tax_amount: Optional[float] = None
    transaction_type: str = ""  # purchase|refund|payment|transfer
    vendor_name: Optional[str] = None
    account_numbers_masked: List[str] = field(default_factory=list)
    payment_method: Optional[str] = None
    invoice_number: Optional[str] = None
    is_line_items: bool = False
    is_summary: bool = False

    def to_dict(self) -> Dict[str, Any]:
        result = super().to_dict()
        result.update({
            "amounts_detected": self.amounts_detected,
            "currency": self.currency,
            "total_amount": self.total_amount,
            "subtotal_amount": self.subtotal_amount,
            "tax_amount": self.tax_amount,
            "transaction_type": self.transaction_type,
            "vendor_name": self.vendor_name,
            "account_numbers_masked": self.account_numbers_masked,
            "payment_method": self.payment_method,
            "invoice_number": self.invoice_number,
            "is_line_items": self.is_line_items,
            "is_summary": self.is_summary,
        })
        return result


@dataclass
class GovernmentChunkMetadata(UniversalChunkMetadata):
    """Extended metadata for government/official documents."""
    form_id: Optional[str] = None
    form_fields: List[str] = field(default_factory=list)
    legal_references: List[str] = field(default_factory=list)
    agency_name: Optional[str] = None
    effective_date: Optional[str] = None
    expiration_date: Optional[str] = None
    is_instructions: bool = False
    is_certification: bool = False
    authority_cited: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        result = super().to_dict()
        result.update({
            "form_id": self.form_id,
            "form_fields": self.form_fields,
            "legal_references": self.legal_references,
            "agency_name": self.agency_name,
            "effective_date": self.effective_date,
            "expiration_date": self.expiration_date,
            "is_instructions": self.is_instructions,
            "is_certification": self.is_certification,
            "authority_cited": self.authority_cited,
        })
        return result


def get_metadata_class_for_domain(domain: str):
    """Get the appropriate metadata class for a given domain."""
    domain_to_class = {
        "legal": LegalChunkMetadata,
        "academic": AcademicChunkMetadata,
        "medical": MedicalChunkMetadata,
        "engineering": EngineeringChunkMetadata,
        "education": EducationChunkMetadata,
        "financial": FinancialChunkMetadata,
        "government": GovernmentChunkMetadata,
    }
    return domain_to_class.get(domain.lower(), UniversalChunkMetadata)
